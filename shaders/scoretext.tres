[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;
//render_mode unshaded;

uniform float bps;
//uniform vec4 star_color : hint_color;
//uniform vec4 held_color : hint_color;

// All components are in the range [0â€¦1], including hue.
vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void fragment() {
	float wave_scale = 0.015;
	float timescale = 0.2;
	float t = TIME * timescale;
	vec3 hsv;
//	hsv.x = 0.5 + 0.5*sin(wave_scale*FRAGCOORD.x+TIME*3.0);
//	hsv.y = 0.5 + 0.5*sin(wave_scale*FRAGCOORD.y+TIME*2.5);
//	hsv.z = 0.5 + 0.5*sin(wave_scale*FRAGCOORD.x+wave_scale*FRAGCOORD.y*cos(TIME*0.01)+TIME*3.5);
	hsv.x = mod(wave_scale*wave_scale*FRAGCOORD.x+t*1.3 + 0.33*sin(wave_scale*FRAGCOORD.y+t*0.5) + 0.33*sin(wave_scale*FRAGCOORD.x+t*0.25), 1.0);
	hsv.y = 0.5 + 0.25*sin(wave_scale*FRAGCOORD.y+t*2.5) + 0.25*cos(wave_scale*FRAGCOORD.x+t*3.5);
	hsv.z = 0.75 + 0.25*sin(wave_scale*FRAGCOORD.x+wave_scale*FRAGCOORD.y*cos(t*0.01)+t*1.5);
	if (COLOR.x >= 0.5) COLOR.rgb = hsv2rgb(hsv); else COLOR.rgb = vec3(1.0) - hsv2rgb(hsv);
	
//	if (color_scale < 0.5){ // Make black outlines shine
//		COLOR.rgb = mix(COLOR.rgb, vec3(mix(dist_norm, abs(0.5-mod(TIME*bps*8.0, 1.0)), 0.33)), 1.0-(color_scale*2.0));
//	}
//	COLOR.rgb = mix(COLOR.rgb, vec3(1.0), 0.1);  // brighten overall
//	COLOR.rgb = mix(COLOR.rgb, vec3(0.25), color_scale);  // Invert white outlines
	
	COLOR.a = clamp(texture(TEXTURE, UV).a, 0.0, 1.0);
}"

[resource]
shader = SubResource( 1 )
shader_param/bps = null
